# Bash-скрипты

[Bash-скрипты: начало](#user-content-bash-скрипты-начало)  
[Bash-скрипты, часть 2: циклы](#user-content-bash-скрипты-часть-2-циклы)  
[Bash-скрипты, часть 3: параметры и ключи командной строки](#user-content-bash-скрипты-часть-3-параметры-и-ключи-командной-строки)  
[Bash-скрипты, часть 4: ввод и вывод]()  
[Bash-скрипты, часть 5: сигналы, фоновые задачи, управление сценариями]()  
[Bash-скрипты, часть 6: функции и разработка библиотек]()  
[Bash-скрипты, часть 7: sed и обработка текстов]()  
[Bash-скрипты, часть 8: язык обработки данных awk]()  
[Bash-скрипты, часть 9: регулярные выражения]()  
[Bash-скрипты, часть 10: практические примеры]()  
[Bash-скрипты, часть 11: expect и автоматизация интерактивных утилит]()

# Bash-скрипты: начало

## Как устроены bash-скрипты

  
Создайте пустой файл с использованием команды `touch`. В его первой строке нужно указать, какую именно оболочку мы собираемся использовать. Нас интересует `bash`, поэтому первая строка файла будет такой:  
  

```bash
#!/bin/bash
```

  
В других строках этого файла символ решётки используется для обозначения комментариев, которые оболочка не обрабатывает. Однако, первая строка — это особый случай, здесь решётка, за которой следует восклицательный знак (эту последовательность называют [шебанг](https://ru.wikipedia.org/wiki/%D0%A8%D0%B5%D0%B1%D0%B0%D0%BD%D0%B3_(Unix))) и путь к`bash`, указывают системе на то, что сценарий создан именно для `bash`.  
  
Команды оболочки отделяются знаком перевода строки, комментарии выделяют знаком решётки. Вот как это выглядит:  
  

```bash
#!/bin/bash
# This is a comment
pwd
whoami
```

  
Тут, так же, как и в командной строке, можно записывать команды в одной строке, разделяя точкой с запятой. Однако, если писать команды на разных строках, файл легче читать. В любом случае оболочка их обработает.  
  

## Установка разрешений для файла сценария

  
Сохраните файл, дав ему имя`myscript`, и работа по созданию bash-скрипта почти закончена. Сейчас осталось лишь сделать этот файл исполняемым, иначе, попытавшись его запустить, вы столкнётесь с ошибкой`Permission denied`.  
  

![](/images/29f7433ec002900e7518396a814fe351.png)

  
_Попытка запуска файла сценария с неправильно настроенными разрешениями_  
  
Сделаем файл исполняемым:  
  

```
chmod +x ./myscript
```

  
Теперь попытаемся его выполнить:  
  

```
./myscript
```

  
После настройки разрешений всё работает как надо.  
  

![](/images/736e671a5ff9a96e10bbb3c7e8ae537a.png)

  
_Успешный запуск bash-скрипта_  
  

## Вывод сообщений

  
Для вывода текста в консоль Linux применяется команда`echo`. Воспользуемся знанием этого факта и отредактируем наш скрипт, добавив пояснения к данным, которые выводят уже имеющиеся в нём команды:  
  

```bash
#!/bin/bash
# our comment is here
echo "The current directory is:"
pwd
echo "The user logged in is:"
whoami
```

  
Вот что получится после запуска обновлённого скрипта.  
  

![](/images/4d0173e3ddcad01d0790b6b98dd91315.png)

  
_Вывод сообщений из скрипта_  
  
Теперь мы можем выводить поясняющие надписи, используя команду`echo`. Если вы не знаете, как отредактировать файл, пользуясь средствами Linux, или раньше не встречались с командой`echo`, взгляните на[этот](https://likegeeks.com/basic-linux-commands-part2/)материал.  
  

## Использование переменных

  
Переменные позволяют хранить в файле сценария информацию, например — результаты работы команд для использования их другими командами.  
  
Нет ничего плохого в исполнении отдельных команд без хранения результатов их работы, но возможности такого подхода весьма ограничены.  
  
Существуют два типа переменных, которые можно использовать в bash-скриптах:  
  

*   Переменные среды
*   Пользовательские переменные

  

## Переменные среды

  
Иногда в командах оболочки нужно работать с некими системными данными. Вот, например, как вывести домашнюю директорию текущего пользователя:  
  

```bash
#!/bin/bash
# display user home
echo "Home for the current user is: $HOME"
```

  
Обратите внимание на то, что мы можем использовать системную переменную`$HOME`в двойных кавычках, это не помешает системе её распознать. Вот что получится, если выполнить вышеприведённый сценарий.  
  

![](/images/da06b64a489f6a8e16a3ca345f270f82.png)

  
_Использование переменной среды в сценарии_  
  
А что если надо вывести на экран значок доллара? Попробуем так:  
  

```bash
echo "I have $1 in my pocket"
```

  
Система обнаружит знак доллара в строке, ограниченной кавычками, и решит, что мы сослались на переменную. Скрипт попытается вывести на экран значение неопределённой переменной`$1`. Это не то, что нам нужно. Что делать?  
  
В подобной ситуации поможет использование управляющего символа, обратной косой черты, перед знаком доллара:  
  

```bash
echo "I have \$1 in my pocket"
```

  
Теперь сценарий выведет именно то, что ожидается.  
  

![](/images/771a8a7102c7a25f1ecd1e739a00de6e.png)

  
_Использование управляющей последовательности для вывода знака доллара_  
  

## Пользовательские переменные

  
В дополнение к переменным среды, bash-скрипты позволяют задавать и использовать в сценарии собственные переменные. Подобные переменные хранят значение до тех пор, пока не завершится выполнение сценария.  
  
Как и в случае с системными переменными, к пользовательским переменным можно обращаться, используя знак доллара:  
TNW-CUS-FMP — промо-код на 10% скидку на наши услуги, доступен для активации в течение 7 дней  

```bash
#!/bin/bash
# testing variables
grade=5
person="Adam"
echo "$person is a good boy, he is in grade $grade"
```

  
Вот что получится после запуска такого сценария.  
  

![](/images/3a736714c8f9db68ef8fce923b3cc5e5.png)

  
_Пользовательские переменные в сценарии_  
  

## Подстановка команд

  
Одна из самых полезных возможностей bash-скриптов — это возможность извлекать информацию из вывода команд и назначать её переменным, что позволяет использовать эту информацию где угодно в файле сценария.  
  
Сделать это можно двумя способами.  
  

*   С помощью значка обратного апострофа «\`»
*   С помощью конструкции`$()`

  
Используя первый подход, проследите за тем, чтобы вместо обратного апострофа не ввести одиночную кавычку. Команду нужно заключить в два таких значка:  
  

```bash
mydir=`pwd`
```

  
При втором подходе то же самое записывают так:  
  

```bash
mydir=$(pwd)
```

  
А скрипт, в итоге, может выглядеть так:  
  

```bash
#!/bin/bash
mydir=$(pwd)
echo $mydir
```

  
В ходе его работы вывод команды`pwd`будет сохранён в переменной`mydir`, содержимое которой, с помощью команды`echo`, попадёт в консоль.  
  

![](/images/acc127fa3826130cb82854c74d6fd5f4.png)

  
_Скрипт, сохраняющий результаты работы команды в переменной_  
  

## Математические операции

  
Для выполнения математических операций в файле скрипта можно использовать конструкцию вида`$((a+b))`:  
  

```bash
#!/bin/bash
var1=$(( 5 + 5 ))
echo $var1
var2=$(( $var1 * 2 ))
echo $var2
```

  

![](/images/a3c9b03dcc99367ba2e80f3695282154.png)

  
_Математические операции в сценарии_  
  

## Управляющая конструкция if-then

  
В некоторых сценариях требуется управлять потоком исполнения команд. Например, если некое значение больше пяти, нужно выполнить одно действие, в противном случае — другое. Подобное применимо в очень многих ситуациях, и здесь нам поможет управляющая конструкция`if-then`. В наиболее простом виде она выглядит так:  
  

```bash
if команда
then
команды
fi
```

  
А вот рабочий пример:  
  

```bash
#!/bin/bash
if pwd
then
echo "It works"
fi
```

  
В данном случае, если выполнение команды`pwd`завершится успешно, в консоль будет выведен текст «it works».  
  
Воспользуемся имеющимися у нас знаниями и напишем более сложный сценарий. Скажем, надо найти некоего пользователя в`/etc/passwd`, и если найти его удалось, сообщить о том, что он существует.  
  

```bash
#!/bin/bash
user=likegeeks
if grep $user /etc/passwd
then
echo "The user $user Exists"
fi
```

  
Вот что получается после запуска этого скрипта.  
  

![](/images/395e1765efb8d9b3fe1726240357dcc4.png)

  
_Поиск пользователя_  
  
Здесь мы воспользовались командой`grep`для поиска пользователя в файле`/etc/passwd`. Если команда`grep`вам незнакома, её описание можно найти[здесь](https://likegeeks.com/main-linux-commands-easy-guide/).  
  
В этом примере, если пользователь найден, скрипт выведет соответствующее сообщение. А если найти пользователя не удалось? В данном случае скрипт просто завершит выполнение, ничего нам не сообщив. Хотелось бы, чтобы он сказал нам и об этом, поэтому усовершенствуем код.  
  

## Управляющая конструкция if-then-else

  
Для того, чтобы программа смогла сообщить и о результатах успешного поиска, и о неудаче, воспользуемся конструкцией`if-then-else`. Вот как она устроена:  
  

```bash
if команда
then
команды
else
команды
fi
```

  
Если первая команда возвратит ноль, что означает её успешное выполнение, условие окажется истинным и выполнение не пойдёт по ветке`else`. В противном случае, если будет возвращено что-то, отличающееся от нуля, что будет означать неудачу, или ложный результат, будут выполнены команды, расположенные после`else`.  
  
Напишем такой скрипт:  
  

```bash
#!/bin/bash
user=anotherUser
if grep $user /etc/passwd
then
echo "The user $user Exists"
else
echo "The user $user doesn’t exist"
fi
```

  
Его исполнение пошло по ветке`else`.  
  

![](/images/9dbc75b3dba2778a9aa9ff6b77677328.png)

  
_Запуск скрипта с конструкцией if-then-else_  
  
Ну что же, продолжаем двигаться дальше и зададимся вопросом о более сложных условиях. Что если надо проверить не одно условие, а несколько? Например, если нужный пользователь найден, надо вывести одно сообщение, если выполняется ещё какое-то условие — ещё одно сообщение, и так далее. В подобной ситуации нам помогут вложенные условия. Выглядит это так:  
  

```bash
if команда1
then
команды
elif команда2
then
команды
fi
```

  
Если первая команда вернёт ноль, что говорит о её успешном выполнении, выполнятся команды в первом блоке`then`, иначе, если первое условие окажется ложным, и если вторая команда вернёт ноль, выполнится второй блок кода.  
  

```bash
#!/bin/bash
user=anotherUser
if grep $user /etc/passwd
then
echo "The user $user Exists"
elif ls /home
then
echo "The user doesn’t exist but anyway there is a directory under /home"
fi
```

  
В подобном скрипте можно, например, создавать нового пользователя с помощью команды`useradd`, если поиск не дал результатов, или делать ещё что-нибудь полезное.  
  

## Сравнение чисел

  
В скриптах можно сравнивать числовые значения. Ниже приведён список соответствующих команд.  
  

> `n1 -eq n2`Возвращает истинное значение, если`n1`равно`n2`.  
> `n1 -ge n2`Возвращает истинное значение, если`n1`больше или равно`n2`.  
> `n1 -gt n2`Возвращает истинное значение, если`n1`больше`n2`.  
> `n1 -le n2`Возвращает истинное значение, если`n1`меньше или равно`n2`.  
> `n1 -lt n2`Возвращает истинное значение, если n1 меньше`n2`.  
> `n1 -ne n2`Возвращает истинное значение, если`n1`не равно`n2`.

  
В качестве примера опробуем один из операторов сравнения. Обратите внимание на то, что выражение заключено в квадратные скобки.  
  

```bash
#!/bin/bash
val1=6
if [ $val1 -gt 5 ]
then
echo "The test value $val1 is greater than 5"
else
echo "The test value $val1 is not greater than 5"
fi
```

  
Вот что выведет эта команда.  
  

![](/images/bd850959bf5385f0e3a3fa2173fb39a8.png)

  
_Сравнение чисел в скриптах_  
  
Значение переменной`val1`больше чем 5, в итоге выполняется ветвь`then`оператора сравнения и в консоль выводится соответствующее сообщение.  
  

## Сравнение строк

  
В сценариях можно сравнивать и строковые значения. Операторы сравнения выглядят довольно просто, однако у операций сравнения строк есть определённые особенности, которых мы коснёмся ниже. Вот список операторов.  
  

> `str1 = str2`Проверяет строки на равенство, возвращает истину, если строки идентичны.  
> s`tr1 != str2`Возвращает истину, если строки не идентичны.  
> `str1 < str2`Возвращает истину, если`str1`меньше, чем`str2`.  
> `str1 > str2`Возвращает истину, если`str1`больше, чем`str2`.  
> `-n str1`Возвращает истину, если длина`str1`больше нуля.  
> `-z str1`Возвращает истину, если длина`str1`равна нулю.

  
Вот пример сравнения строк в сценарии:  
  

```bash
#!/bin/bash
user ="likegeeks"
if [$user = $USER]
then
echo "The user $user  is the current logged in user"
fi
```

  
В результате выполнения скрипта получим следующее.  
  

![](/images/55c79a3f28c78c48bcb0560236e09f9c.png)

  
_Сравнение строк в скриптах_  
  
Вот одна особенность сравнения строк, о которой стоит упомянуть. А именно, операторы «>» и «<» необходимо экранировать с помощью обратной косой черты, иначе скрипт будет работать неправильно, хотя сообщений об ошибках и не появится. Скрипт интерпретирует знак «>» как команду перенаправления вывода.  
  
Вот как работа с этими операторами выглядит в коде:  
  

```bash
#!/bin/bash
val1=text
val2="another text"
if [ $val1 \> $val2 ]
then
echo "$val1 is greater than $val2"
else
echo "$val1 is less than $val2"
fi
```

  
Вот результаты работы скрипта.  
  

![](/images/4cf2c4079e42367f9e061cfee547e6b0.png)

  
_Сравнение строк, выведенное предупреждение_  
  
Обратите внимание на то, что скрипт, хотя и выполняется, выдаёт предупреждение:  
  

```
./myscript: line 5: [: too many arguments
```

  
Для того, чтобы избавиться от этого предупреждения, заключим`$val2`в двойные кавычки:  
  

```bash
#!/bin/bash
val1=text
val2="another text"
if [ $val1 \> "$val2" ]
then
echo "$val1 is greater than $val2"
else
echo "$val1 is less than $val2"
fi
```

  
Теперь всё работает как надо.  
  

![](/images/8e9cd9a8f743b7789841173671cfe26c.png)

  
_Сравнение строк_  
  
Ещё одна особенность операторов «>» и «<» заключается в том, как они работают с символами в верхнем и нижнем регистрах. Для того, чтобы понять эту особенность, подготовим текстовый файл с таким содержимым:  
  

```
Likegeeks
likegeeks
```

  
Сохраним его, дав имя`myfile`, после чего выполним в терминале такую команду:  
  

```
sort myfile
```

  
Она отсортирует строки из файла так:  
  

```
likegeeks
Likegeeks
```

  
Команда`sort`, по умолчанию, сортирует строки по возрастанию, то есть строчная буква в нашем примере меньше прописной. Теперь подготовим скрипт, который будет сравнивать те же строки:  
  

```bash
#!/bin/bash
val1=Likegeeks
val2=likegeeks
if [ $val1 \> $val2 ]
then
echo "$val1 is greater than $val2"
else
echo "$val1 is less than $val2"
fi
```

  
Если его запустить, окажется, что всё наоборот — строчная буква теперь больше прописной.  
  

![](/images/ccac6688ceb2d01f4e906620c8c0244a.png)

  
_Команда sort и сравнение строк в файле сценария_  
  
В командах сравнения прописные буквы меньше строчных. Сравнение строк здесь выполняется путём сравнения ASCII-кодов символов, порядок сортировки, таким образом, зависит от кодов символов.  
  
Команда`sort`, в свою очередь, использует порядок сортировки, заданный в настройках системного языка.  
  

## Проверки файлов

  
Пожалуй, нижеприведённые команды используются в bash-скриптах чаще всего. Они позволяют проверять различные условия, касающиеся файлов. Вот список этих команд.  
  

> `-d file`Проверяет, существует ли файл, и является ли он директорией.  
> `-e file`Проверяет, существует ли файл.  
> `-f file`Проверяет, существует ли файл, и является ли он файлом.  
> `-r file`Проверяет, существует ли файл, и доступен ли он для чтения.  
> `-s file П`роверяет, существует ли файл, и не является ли он пустым.  
> `-w file`Проверяет, существует ли файл, и доступен ли он для записи.  
> `-x file`Проверяет, существует ли файл, и является ли он исполняемым.  
> `file1 -nt file2`Проверяет, новее ли`file1`, чем`file2`.  
> `file1 -ot file2`Проверяет, старше ли`file1`, чем`file2`.  
> `-O file`Проверяет, существует ли файл, и является ли его владельцем текущий пользователь.  
> `-G file`Проверяет, существует ли файл, и соответствует ли его идентификатор группы идентификатору группы текущего пользователя.

  
Эти команды, как впрочем, и многие другие рассмотренные сегодня, несложно запомнить. Их имена, являясь сокращениями от различных слов, прямо указывают на выполняемые ими проверки.  
  
Опробуем одну из команд на практике:  
  

```bash
#!/bin/bash
mydir=/home/likegeeks
if [ -d $mydir ]
then
echo "The $mydir directory exists"
cd $ mydir
ls
else
echo "The $mydir directory does not exist"
fi
```

  
Этот скрипт, для существующей директории, выведет её содержимое.  
  

![](/images/ab22e20e730bb0c56cef8da5c8d31dba.png)

  
_Вывод содержимого директории_  
  
Полагаем, с остальными командами вы сможете поэкспериментировать самостоятельно, все они применяются по тому же принципу.

# Bash-скрипты, часть 2: циклы

## Циклы for

  
Оболочка bash поддерживает циклы`for`, которые позволяют организовывать перебор последовательностей значений. Вот какова базовая структура таких циклов:  
  

```bash
for var in list
do
команды
done
```

  
В каждой итерации цикла в переменную`var`будет записываться следующее значение из списка`list`. В первом проходе цикла, таким образом, будет задействовано первое значение из списка. Во втором — второе, и так далее — до тех пор, пока цикл не дойдёт до последнего элемента.  
  

## Перебор простых значений

  
Пожалуй, самый простой пример цикла`for`в bash-скриптах — это перебор списка простых значений:  
  

```bash
#!/bin/bash
for var in first second third fourth fifth
do
echo The  $var item
done
```

  
Ниже показаны результаты работы этого скрипта. Хорошо видно, что в переменную`$var`последовательно попадают элементы из списка. Происходит так до тех пор, пока цикл не дойдёт до последнего из них.  
  
![](/images/029f5b70be710c0aab128d612e7ca4bc.png)  
_Простой цикл for_  
  
Обратите внимание на то, что переменная`$var`сохраняет значение при выходе из цикла, её содержимое можно менять, в целом, работать с ней можно как с любой другой переменной.  
  

## Перебор сложных значений

  
В списке, использованном при инициализации цикла`for`, могут содержаться не только простые строки, состоящие из одного слова, но и целые фразы, в которые входят несколько слов и знаков препинания. Например, всё это может выглядеть так:  
  

```bash
#!/bin/bash
for var in first "the second" "the third" "I’ll do it"
do
echo "This is: $var"
done
```

  
Вот что получится после того, как этот цикл пройдётся по списку. Как видите, результат вполне ожидаем.  
  
![](/images/2e5e3f0e856ee457a7c821f1fa3126b8.png)  
_Перебор сложных значений_  
TNW-CUS-FMP — промо-код на 10% скидку на наши услуги, доступен для активации в течение 7 дней"  

## Инициализация цикла списком, полученным из результатов работы команды

  
Ещё один способ инициализации цикла`for`заключается в передаче ему списка, который является результатом работы некоей команды. Тут используется подстановка команд для их исполнения и получения результатов их работы.  
  

```bash
#!/bin/bash
file="myfile"
for var in $(cat $file)
do
echo " $var"
done
```

  
В этом примере задействована команда`cat`, которая читает содержимое файла. Полученный список значений передаётся в цикл и выводится на экран. Обратите внимание на то, что в файле, к которому мы обращаемся, содержится список слов, разделённых знаками перевода строки, пробелы при этом не используются.  
  
![](/images/84276530b0d56f7d038aaa0a1f80906f.png)  
_Цикл, который перебирает содержимое файла_  
  
Тут надо учесть, что подобный подход, если ожидается построчная обработка данных, не сработает для файла более сложной структуры, в строках которого может содержаться по несколько слов, разделённых пробелами. Цикл будет обрабатывать отдельные слова, а не строки.  
  
Что, если это совсем не то, что нужно?  
  

## Разделители полей

  
Причина вышеописанной особенности заключается в специальной переменной окружения, которая называется`IFS`(Internal Field Separator) и позволяет указывать разделители полей. По умолчанию оболочка bash считает разделителями полей следующие символы:  
  

*   Пробел
*   Знак табуляции
*   Знак перевода строки

  
Если bash встречает в данных любой из этих символов, он считает, что перед ним — следующее самостоятельное значение списка.  
  
Для того, чтобы решить проблему, можно временно изменить переменную среды`IFS`. Вот как это сделать в bash-скрипте, если исходить из предположения, что в качестве разделителя полей нужен только перевод строки:  
  

```bash
IFS=$'\n'
```

  
После добавления этой команды в bash-скрипт, он будет работать как надо, игнорируя пробелы и знаки табуляции, считая разделителями полей лишь символы перевода строки.  
  

```bash
#!/bin/bash
file="/etc/passwd"
IFS=$'\n'
for var in $(cat $file)
do
echo " $var"
done
```

  
Если этот скрипт запустить, он выведет он именно то, что от него требуется, давая, в каждой итерации цикла, доступ к очередной строке, записанной в файл.  
  
![](/images/6f7574e2270854b6200d686ab2682676.png)  
_Построчный обход содержимого файла в цикле for_  
  
Разделителями могут быть и другие символы. Например, выше мы выводили на экран содержимое файла`/etc/passwd`. Данные о пользователях в строках разделены с помощью двоеточий. Если в цикле нужно обрабатывать подобные строки,`IFS`можно настроить так:  
  

```bash
IFS=:
```

  

## Обход файлов, содержащихся в директории

  
Один из самых распространённых вариантов использования циклов`for`в bash-скриптах заключается в обходе файлов, находящихся в некоей директории, и в обработке этих файлов.  
  
Например, вот как можно вывести список файлов и папок:  
  

```bash
#!/bin/bash
for file in /home/likegeeks/*
do
if [ -d "$file" ]
then
echo "$file is a directory"
elif [ -f "$file" ]
then
echo "$file is a file"
fi
done
```

  
Если вы разобрались с[предыдущим материалом](https://habrahabr.ru/company/ruvds/blog/325522/)из этой серии статей, вам должно быть понятно устройство конструкции`if-then`, а так же то, как отличить файл от папки. Если вам сложно понять вышеприведённый код, перечитайте этот материал.  
  
Вот что выведет скрипт.  
  
![](/images/ec6291ec1b9fbd8e262035bd0bea80c0.png)  
_Вывод содержимого папки_  
  
Обратите внимание на то, как мы инициализируем цикл, а именно — на подстановочный знак «\*» в конце адреса папки. Этот символ можно воспринимать как шаблон, означающий: «все файлы с любыми именами». он позволяет организовать автоматическую подстановку имён файлов, которые соответствуют шаблону.  
  
При проверке условия в операторе`if`, мы заключаем имя переменной в кавычки. Сделано это потому что имя файла или папки может содержать пробелы.  
  

## Циклы for в стиле C

  
Если вы знакомы с языком программирования C, синтаксис описания bash-циклов`for`может показаться вам странным, так как привыкли вы, очевидно, к такому описанию циклов:  
  

```bash
for (i = 0; i < 10; i++)
{
printf("number is %d\n", i);
}
```

  
В bash-скриптах можно использовать циклы`for`, описание которых выглядит очень похожим на циклы в стиле C, правда, без некоторых отличий тут не обошлось. Схема цикла при подобном подходе выглядит так:  
  

```bash
for (( начальное значение переменной ; условие окончания цикла; изменение переменной ))
```

  
На bash это можно написать так:  
  

```bash
for (( a = 1; a < 10; a++ ))
```

  
А вот рабочий пример:  
  

```bash
#!/bin/bash
for (( i=1; i <= 10; i++ ))
do
echo "number is $i"
done
```

  
Этот код выведет список чисел от 1 до 10.  
  
![](/images/8-guFEwLQA0SipmlUF_kzBsryGEkadB6YpmmNL62_-2Dl-tUywrP1mEFU_Fy8jhU9jyid3WF7RAHkBv-rYJUmDVp7TFSKx3bYQZ6qFwtP1Bz4lIx5dbFRB9W1zI7ABbeus3QV--1P3X8jubvOw)  
_Работа цикла в стиле C_  
  

## Цикл while

  
Конструкция`for —`не единственный способ организации циклов в bash-скриптах. Здесь можно пользоваться и циклами`while`. В таком цикле можно задать команду проверки некоего условия и выполнять тело цикла до тех пор, пока проверяемое условие возвращает ноль, или сигнал успешного завершения некоей операции. Когда условие цикла вернёт ненулевое значение, что означает ошибку, цикл остановится.  
  
Вот схема организации циклов`while  
while команда проверки условия  
do  
другие команды  
done`  
  
Взглянем на пример скрипта с таким циклом:  
  

```bash
#!/bin/bash
var1=5
while [ $var1 -gt 0 ]
do
echo $var1
var1=$[ $var1 - 1 ]
done
```

  
На входе в цикл проверяется, больше ли нуля переменная`$var1`. Если это так, выполняется тело цикла, в котором из значения переменной вычитается единица. Так происходит в каждой итерации, при этом мы выводим в консоль значение переменной до его модификации. Как только`$var1`примет значение 0, цикл прекращается.  
  
![](/images/K5622UUyXnl1vSr1fN3I6OHVs13jA8Huyge-OdZ7y9lJ0HRGEMlcpFb__ouQjveVOtyQzz0xHUh_gyncw28oBk1oI7PGJUVUAG0tagG7BqX7ir7flGkO7qHkV5i8TKgpn-y_LXoYAccT2fKYnw)  
_Результат работы цикла while_  
  
Если не модифицировать переменную`$var1`, это приведёт к попаданию скрипта в бесконечный цикл.  
  

## Вложенные циклы

  
В теле цикла можно использовать любые команды, в том числе — запускать другие циклы. Такие конструкции называют вложенными циклами:  
  

```bash
#!/bin/bash
for (( a = 1; a <= 3; a++ ))
do
echo "Start $a:"
for (( b = 1; b <= 3; b++ ))
do
echo " Inner loop: $b"
done
done
```

  
Ниже показано то, что выведет этот скрипт. Как видно, сначала выполняется первая итерация внешнего цикла, потом — три итерации внутреннего, после его завершения снова в дело вступает внешний цикл, потом опять — внутренний.  
  
![](/images/K7DsBP72Y0CQuHSL3X-HmcYhfgsQtsEXwpEU8Xr1dQFsKRHZQ7LqyuhfUhdReJGxW2gbAoGXBSB1VeM7r5cmH7HG9VWkhaEy7UzZ3YEHIO_E3ND_w5mZtD4Bd-i0Ml3hSSWKHRurziyR_7v_Fg)  
_Вложенные циклы_  
  

## Обработка содержимого файла

  
Чаще всего вложенные циклы используют для обработки файлов. Так, внешний цикл занимается перебором строк файла, а внутренний уже работает с каждой строкой. Вот, например, как выглядит обработка файла`/etc/passwd`:  
  

```bash
#!/bin/bash
IFS=$'\n'
for entry in $(cat /etc/passwd)
do
echo "Values in $entry –"
IFS=:
for value in $entry
do
echo " $value"
done
done
```

  
В этом скрипте два цикла. Первый проходится по строкам, используя в качестве разделителя знак перевода строки. Внутренний занят разбором строк, поля которых разделены двоеточиями.  
  
![](/images/-UGOy-2GpL_7qZWtQBuWR8oQrH0aXWpQouE0wIZyuuadWJRchjUC6YWZqfNLdb3u7ECzf_N3pbz2rE3VR_9ptwGQKruBLARv1c_ZlnGvi0uNICw2le_aIRZxP88us9iWdLxxfEr81Glj52oQAw)  
_Обработка данных файла_  
  
Такой подход можно использовать при обработке файлов формата CSV, или любых подобных файлов, записывая, по мере надобности, в переменную окружения`IFS`символ-разделитель.  
  

## Управление циклами

  
Возможно, после входа в цикл, нужно будет остановить его при достижении переменной цикла определённого значения, которое не соответствует изначально заданному условию окончания цикла. Надо ли будет в такой ситуации дожидаться нормального завершения цикла? Нет конечно, и в подобных случаях пригодятся следующие две команды:  
  

*   `break`
*   `continue`

  

## Команда break

  
Эта команда позволяет прервать выполнение цикла. Её можно использовать и для циклов`for`, и для циклов`while`:  
  

```bash
#!/bin/bash
for var1 in 1 2 3 4 5 6 7 8 9 10
do
if [ $var1 -eq 5 ]
then
break
fi
echo "Number: $var1"
done
```

  
Такой цикл, в обычных условиях, пройдётся по всему списку значений из списка. Однако, в нашем случае, его выполнение будет прервано, когда переменная`$var1`будет равна 5.  
  
![](/images/jg4xtN1I0tln8w8dm_b5XtbHIbd5yI2EAg6ziWENCpt-GAiU4prXiarHbnzWMzK-wajj3aRlwSKXi2uIjdAvaKGos4ReXP46AytgRFap0-PiD23ikSAX4ZvD1mRpYxWkbUzTf1P5MS8gQiXIkw)  
_Досрочный выход из цикла for_  
  
Вот — то же самое, но уже для цикла`while`:  
  

```bash
#!/bin/bash
var1=1
while [ $var1 -lt 10 ]
do
if [ $var1 -eq 5 ]
then
break
fi
echo "Iteration: $var1"
var1=$(( $var1 + 1 ))
done
```

  
Команда`break`, исполненная, когда значение`$var1`станет равно 5, прерывает цикл. В консоль выведется то же самое, что и в предыдущем примере.  
  

## Команда continue

  
Когда в теле цикла встречается эта команда, текущая итерация завершается досрочно и начинается следующая, при этом выхода из цикла не происходит. Посмотрим на команду`continue`в цикле`for`:  
  

```bash
#!/bin/bash
for (( var1 = 1; var1 < 15; var1++ ))
do
if [ $var1 -gt 5 ] && [ $var1 -lt 10 ]
then
continue
fi
echo "Iteration number: $var1"
done
```

  
Когда условие внутри цикла выполняется, то есть, когда`$var1`больше 5 и меньше 10, оболочка исполняет команду`continue`. Это приводит к пропуску оставшихся в теле цикла команд и переходу к следующей итерации.  
  
![](/images/DDo9QcLuEBjIHQkg9HyusIc3A1FzUWxFKojTylwEcRdMLBvW5xv8Wofn1zbz4Usogq2l2JM3qg8f4rv9odlF6ozzoMrPD7zBWSRWp32--pok6xm0DowP7GczN2QjhTnUm9rk2fDeIHnAuhcxdA)  
_Команда continue в цикле for_  
  

## Обработка вывода, выполняемого в цикле

  
Данные, выводимые в цикле, можно обработать, либо перенаправив вывод, либо передав их в конвейер. Делается это с помощью добавления команд обработки вывода после инструкции`done`.  
  
Например, вместо того, чтобы показывать на экране то, что выводится в цикле, можно записать всё это в файл или передать ещё куда-нибудь:  
  

```bash
#!/bin/bash
for (( a = 1; a < 10; a++ ))
do
echo "Number is $a"
done > myfile.txt
echo "finished."
```

  
Оболочка создаст файл`myfile.txt`и перенаправит в этот файл вывод конструкции`for`. Откроем файл и удостоверимся в том, что он содержит именно то, что ожидается.  
  
![](/images/AsNK_vEGXArctfRWFAThFNvAOW5HbLQqksos7Ul6_WJke0QLYj1DA0Hs65hPL0JbXhbdDgxz5ZDkLfTVNhNqRrB8CUyIb-T1IzwRGnzT_x_FVah19HRAMMicXLqrhn0NZieQBvIDVIrsOrqMEQ)  
_Перенаправление вывода цикла в файл_  
  

## Пример: поиск исполняемых файлов

  
Давайте воспользуемся тем, что мы уже разобрали, и напишем что-нибудь полезное. Например, если надо выяснить, какие именно исполняемые файлы доступны в системе, можно просканировать все папки, записанные в переменную окружения`PATH`. Весь арсенал средств, который для этого нужен, у нас уже есть, надо лишь собрать всё это воедино:  
  

```bash
#!/bin/bash
IFS=:
for folder in $PATH
do
echo "$folder:"
for file in $folder/*
do
if [ -x $file ]
then
echo " $file"
fi
done
done
```

  
Такой вот скрипт, небольшой и несложный, позволил получить список исполняемых файлов, хранящихся в папках из`PATH`.  
  
![](/images/FZHEGCXR9tyDXnMNVHV9voO5YxjW3Kb3tasZNXiTztDqdd1eaNjGm8EEFUM3U2e3_VC0GSY0O_TuTMZC4jKuR9dyyGzLtl0vHfZcpc2ARbAQN_98gAXM_bIucW-h7RD7y2YcKEvFokgJH0ZwUw)  
_Поиск исполняемых файлов в папках из переменной PATH_

# Bash-скрипты, часть 3: параметры и ключи командной строки

## Чтение параметров командной строки

  
Оболочка bash назначает специальным переменным, называемым позиционными параметрами, введённые при вызове скрипта параметры командной строки:  
  

*   `$0` — имя скрипта.  
    
*   `$1` — первый параметр.  
    
*   `$2` — второй параметр — и так далее, вплоть до переменной`$9`, в которую попадает девятый параметр.  
    

  
Вот как можно использовать параметры командной строки в скрипте с помощью этих переменных:  
  

```bash
#!/bin/bash
echo $0
echo $1
echo $2
echo $3
```

  
Запустим сценарий с параметрами:  
  

```
./myscript 5 10 15
```

  
Вот что он выведет в консоль.  
  

![](/images/fb5f9fb80361a4083e31d7225fa3cdbf.png)

  
_Вывод параметров, с которыми запущен скрипт_  
  
Обратите внимание на то, что параметры командной строки разделяются пробелами.  
  
Взглянем на ещё один пример использования параметров. Тут мы найдём сумму чисел, переданных сценарию:  
  

```bash
#!/bin/bash
total=$[ $1 + $2 ]
echo The first parameter is $1.
echo The second parameter is $2.
echo The sum is $total.
```

  
Запустим скрипт и проверим результат вычислений.  
  

![](/images/646db142c4fe6ebfc41f66b2a65534e6.png)

  
_Сценарий, который находит сумму переданных ему чисел_  
  
Параметры командной строки не обязательно должны быть числами. Сценариям можно передавать и строки. Например, вот скрипт, работающий со строкой:  
  

```bash
#!/bin/bash
echo Hello $1, how do you do
```

  
Запустим его:  
  

```
./myscript Adam
```

  
Он выведет то, что мы от него ожидаем.  
  

![](/images/f450d1b0337e0533990d1a25f2890e43.png)

  
_Сценарий, работающий со строковым параметром_  
  
Что если параметр содержит пробелы, а нам надо обрабатывать его как самостоятельный фрагмент данных? Полагаем, если вы освоили предыдущие части этого руководства, ответ вы уже знаете. Заключается он в использовании кавычек.  
  
Если скрипту надо больше девяти параметров, при обращении к ним номер в имени переменной надо заключать в фигурные скобки, например так:  
  

```bash
${10}
```

  

## Проверка параметров

  
Если скрипт вызван без параметров, но для нормальной работы кода предполагается их наличие, возникнет ошибка. Поэтому рекомендуется всегда проверять наличие параметров, переданных сценарию при вызове. Например, это можно организовать так:  
  

```bash
#!/bin/bash
if [ -n "$1" ]
then
echo Hello $1.
else
echo "No parameters found. "
fi
```

  
Вызовем скрипт сначала с параметром, а потом без параметров.  
  

![](/images/b8c9ce15f6793d007f1d5460a7a20078.png)

  
_Вызов скрипта, проверяющего наличие параметров командной строки_  
  

## Подсчёт параметров

  
В скрипте можно подсчитать количество переданных ему параметров. Оболочка bash предоставляет для этого специальную переменную. А именно, переменная`$#`содержит количество параметров, переданных сценарию при вызове.  
  
Опробуем её:  
  

```bash
#!/bin/bash
echo There were $# parameters passed.
```

  
Вызовем сценарий.  
  

```
./myscript 1 2 3 4 5
```

  
В результате скрипт сообщит о том, что ему передано 5 параметров.  
  

![](/images/b4919fe68032df326b43cc39a88e718d.png)

  
_Подсчёт количества параметров в скрипте_  
  
Эта переменная даёт необычный способ получения последнего из переданных скрипту параметров, не требующий знания их количества. Вот как это выглядит:  
  

```bash
#!/bin/bash
echo The last parameter was ${!#}
```

  
Вызовем скрипт и посмотрим, что он выведет.  
  

![](/images/e7f7ed0e751be4c5156ae49b7e8ea86d.png)

  
_Обращение к последнему параметру_  
  

## Захват всех параметров командной строки

  
В некоторых случаях нужно захватить все параметры, переданные скрипту. Для этого можно воспользоваться переменными`$*`и`$@`. Обе они содержат все параметры командной строки, что делает возможным доступ к тому, что передано сценарию, без использования позиционных параметров.  
  
Переменная`$*`содержит все параметры, введённые в командной строке, в виде единого «слова».  
  
В переменной`$@`параметры разбиты на отдельные «слова». Эти параметры можно перебирать в циклах.  
  
Рассмотрим разницу между этими переменными на примерах. Сначала взглянем на их содержимое:  
  

```bash
#!/bin/bash
echo "Using the \$* method: $*"
echo "-----------"
echo "Using the \$@ method: $@"
```

  
Вот вывод скрипта.  
  

![](/images/ee1579f3d1c96830d6c2484f6124c89e.png)

  
_Переменные $\* и $@_  
  
Как видно, при выводе обеих переменных получается одно и то же. Теперь попробуем пройтись по содержимому этих переменных в циклах для того, чтобы увидеть разницу между ними:  
  

```bash
#!/bin/bash
count=1
for param in "$*"
do
echo "\$* Parameter #$count = $param"
count=$(( $count + 1 ))
done
count=1
for param in "$@"
do
echo "\$@ Parameter #$count = $param"
count=$(( $count + 1 ))
done
```

  
Взгляните на то, что скрипт вывел в консоль. Разница между переменными вполне очевидна.  
  

![](/images/4bd369c4cecd29ae7b221dcdbf669fbb.png)

  
_Разбор переменных $\* и $@ в цикле_  
  
Переменная`$*`содержит все переданные скрипту параметры как единый фрагмент данных, в то время как в переменной`$@`они представлены самостоятельными значениями. Какой именно переменной воспользоваться — зависит от того, что именно нужно в конкретном сценарии.  
  

## Команда shift

  
Использовать команду`shift`в bash-скриптах следует с осторожностью, так как она, в прямом смысле слова, сдвигает значения позиционных параметров.  
  
Когда вы используете эту команду, она, по умолчанию, сдвигает значения позиционных параметров влево. Например, значение переменной`$3`становится значением переменной`$2`, значение`$2`переходит в`$1`, а то, что было до этого в`$1,`теряется. Обратите внимание на то, что при этом значение переменной`$0`, содержащей имя скрипта, не меняется.  
  
Воспользовавшись командой`shift`, рассмотрим ещё один способ перебора переданных скрипту параметров:  
  

```bash
#!/bin/bash
count=1
while [ -n "$1" ]
do
echo "Parameter #$count = $1"
count=$(( $count + 1 ))
shift
done
```

  
Скрипт задействует цикл`while`, проверяя длину значения первого параметра. Когда длина станет равна нулю, происходит выход из цикла. После проверки первого параметра и вывода его на экран, вызывается команда`shift`, которая сдвигает значения параметров на одну позицию.  
  

![](/images/db12d91f92f7e8bc7d62a30471638ed3.png)

  
_Использование команды shift для перебора параметров_  
  
Используя команду`shift`, помните о том, что при каждом её вызове значение переменной`$1`безвозвратно теряется.  
  

## Ключи командной строки

  
Ключи командной строки обычно выглядят как буквы, перед которыми ставится тире. Они служат для управления сценариями. Рассмотрим такой пример:  
  

```bash
#!/bin/bash
echo
while [ -n "$1" ]
do
case "$1" in
-a) echo "Found the -a option" ;;
-b) echo "Found the -b option" ;;
-c) echo "Found the -c option" ;;
*) echo "$1 is not an option" ;;
esac
shift
done
```

  
Запустим скрипт:  
  

```
$ ./myscript –a –b –c –d
```

  
И проанализируем то, что он выведет в терминал.  
  

![](/images/2efa185daf65a2171852f56b40c182fb.png)

  
_Обработка ключей в скрипте_  
  
В этом коде использована конструкция`case`, которая сверяет переданный ей ключ со списком обрабатываемых скриптом ключей. Если переданное значение нашлось в этом списке, выполняется соответствующая ветвь кода. Если при вызове скрипта будет использован любой ключ, обработка которого не предусмотрена, будет исполнена ветвь «\*».  
  

## Как различать ключи и параметры

  
Часто при написании bash-скриптов возникает ситуация, когда надо использовать и параметры командной строки, и ключи. Стандартный способ это сделать заключается в применении специальной последовательности символов, которая сообщает скрипту о том, когда заканчиваются ключи и начинаются обычные параметры.  
  
Эта последовательность — двойное тире (--). Оболочка использует её для указания позиции, на которой заканчивается список ключей. После того, как скрипт обнаружит признак окончания ключей, то, что осталось, можно, не опасаясь ошибок, обрабатывать как параметры, а не как ключи. Рассмотрим пример:  
  

```bash
#!/bin/bash
while [ -n "$1" ]
do
case "$1" in
-a) echo "Found the -a option" ;;
-b) echo "Found the -b option";;
-c) echo "Found the -c option" ;;
--) shift
break ;;
*) echo "$1 is not an option";;
esac
shift
done
count=1
for param in $@
do
echo "Parameter #$count: $param"
count=$(( $count + 1 ))
done
```

  
Этот сценарий использует команду`break`для прерывания цикла`while`при обнаружении в строке двойного тире.  
  
Вот что получится после его вызова.  
  

![](/images/e06806fe1b4bb8c750896fdaa3767f4a.png)

  
_Обработка ключей и параметров командной строки_  
  
Как видно, когда скрипт, разбирая переданные ему данные, находит двойное тире, он завершает обработку ключей и считает всё, что ещё не обработано, параметрами.  
  

## Обработка ключей со значениями

  
По мере усложнения ваших скриптов, вы столкнётесь с ситуациями, когда обычных ключей уже недостаточно, а значит, нужно будет использовать ключи с некими значениями. Например, вызов сценария в котором используется подобная возможность, выглядит так:  
  

```
./myscript -a test1 -b -c test2
```

  
Скрипт должен уметь определять, когда вместе с ключами командной строки используются дополнительные параметры:  
  

```bash
#!/bin/bash
while [ -n "$1" ]
do
case "$1" in
-a) echo "Found the -a option";;
-b) param="$2"
echo "Found the -b option, with parameter value $param"
shift ;;
-c) echo "Found the -c option";;
--) shift
break ;;
*) echo "$1 is not an option";;
esac
shift
done
count=1
for param in "$@"
do
echo "Parameter #$count: $param"
count=$(( $count + 1 ))
done
```

  
Вызовем этот скрипт в таком виде:  
  

```
./myscript -a -b test1 -d
```

  
Посмотрим на результаты его работы.  
  

![](/images/8a8867258b53425258e90111f9763ddb.png)

  
_Обработка параметров ключей_  
  
В данном примере в конструкции`case`обрабатываются три ключа. Ключ`-b`требует наличия дополнительного параметра. Так как обрабатываемый ключ находится в переменной`$1`, соответствующий ему параметр будет находиться в`$2`(тут используется команда`shift`, поэтому, по мере обработки, всё, что передано сценарию, сдвигается влево). Когда с этим мы разобрались, осталось лишь извлечь значение переменной`$2`и у нас будет параметр нужного ключа. Конечно, тут понадобится ещё одна команда`shift`для того, чтобы следующий ключ попал в`$1`.  
  

## Использование стандартных ключей

  
При написании bash-скриптов вы можете выбирать любые буквы для ключей командной строки и произвольно задавать реакцию скрипта на эти ключи. Однако, в мире Linux значения некоторых ключей стали чем-то вроде стандарта, которого полезно придерживаться. Вот список этих ключей:  
  

> `-a`Вывести все объекты.  
> `-c`Произвести подсчёт.  
> `-d`Указать директорию.  
> `-e`Развернуть объект.  
> `-f`Указать файл, из которого нужно прочитать данные.  
> `-h`Вывести справку по команде.  
> `-i`Игнорировать регистр символов.  
> `-l`Выполнить полноформатный вывод данных.  
> `-n`Использовать неинтерактивный (пакетный) режим.  
> `-o`Позволяет указать файл, в который нужно перенаправить вывод.  
> `-q`Выполнить скрипт в quiet-режиме.  
> `-r`Обрабатывать папки и файлы рекурсивно.  
> `-s`Выполнить скрипт в silent-режиме.  
> `-v`Выполнить многословный вывод.  
> `-x`Исключить объект.  
> `-y`Ответить «yes» на все вопросы.

  
Если вы работаете в Linux, вам, скорее всего, знакомы многие из этих ключей. Использовав их в общепринятом значении в своих скриптах, вы поможете пользователям взаимодействовать с ними, не беспокоясь о чтении документации.  
  

## Получение данных от пользователя

  
Ключи и параметры командной строки — это отличный способ получить данные от того, кто пользуется скриптом, однако в некоторых случаях нужно больше интерактивности.  
  
Иногда сценарии нуждаются в данных, которые пользователь должен ввести во время выполнения программы. Именно для этой цели в оболочке bash имеется команда`read`.  
  
Эта команда позволяет принимать введённые данные либо со стандартного ввода (с клавиатуры), либо используя другие дескрипторы файлов. После получения данных, эта команда помещает их в переменную:  
  

```bash
#!/bin/bash
echo -n "Enter your name: "
read name
echo "Hello $name, welcome to my program."
```

  
Обратите внимание на то, что команда `echo`, которая выводит приглашение, вызывается с ключом `-n`. Это приводит к тому, что в конце приглашения не выводится знак перевода строки, что позволяет пользователю скрипта вводить данные там же, где расположено приглашение, а не на следующей строке.  
  

![](/images/53d1ca2de0cdddb76571125d44c79697.png)

  
_Обработка пользовательского ввода_  
  
При вызове`read`можно указывать и несколько переменных:  
  

```bash
#!/bin/bash
read -p "Enter your name: " first last
echo "Your data for $last, $first…"
```

  
Вот что выведет скрипт после запуска.  
  

![](/images/db7d564840726149b098fad0545da7e6.png)

  
_Несколько переменных в команде read_  
  
Если, вызвав `read`, не указывать переменную, данные, введённые пользователем, будут помещены в специальную переменную среды `REPLY`:  
  

```bash
#!/bin/bash
read -p "Enter your name: "
echo Hello $REPLY, welcome to my program.
```

  

![](/images/e7afae7525869d3a0d64ec8d99637fda.png)

  
_Использование переменной среды REPLY_  
  
Если скрипт должен продолжать выполнение независимо от того, введёт пользователь какие-то данные или нет, вызывая команду `read` можно воспользоваться ключом `-t`. А именно, параметр ключа задаёт время ожидания ввода в секундах:  
  

```bash
#!/bin/bash
if read -t 5 -p "Enter your name: " name
then
echo "Hello $name, welcome to my script"
else
echo "Sorry, too slow! "
fi
```

  
Если данные не будут введены в течение 5 секунд, скрипт выполнит ветвь условного оператора `else`, выведя извинения.  
  

![](/images/65c68e9078b67feec2bbddd94c3729b9.png)

  
_Ограничение времени на ввод данных_  
  

## Ввод паролей

  
Иногда то, что вводит пользователь в ответ на вопрос скрипта, лучше на экране не показывать. Например, так обычно делают, запрашивая пароли. Ключ `-s` команды `read` предотвращает отображение на экране данных, вводимых с клавиатуры. На самом деле, данные выводятся, но команда`read`делает цвет текста таким же, как цвет фона.  
  

```bash
#!/bin/bash
read -s -p "Enter your password: " pass
echo "Is your password really $pass? "
```

  
Вот как отработает этот скрипт.  
  

![](/images/3c3fd43bd63034b4d7dc7159ad06da75.png)

  
_Ввод конфиденциальных данных_  
  

## Чтение данных из файла

  
Команда`read`может, при каждом вызове, читать одну строку текста из файла. Когда в файле больше не останется непрочитанных строк, она просто остановится. Если нужно получить в скрипте всё содержимое файла, можно, с помощью конвейера, передать результаты вызова команды`cat`для файла, конструкции`while`, которая содержит команду`read`(конечно, использование команды`cat`выглядит примитивно, но наша цель — показать всё максимально просто, ориентируясь на новичков; опытные пользователи, уверены, это поймут).  
  
Напишем скрипт, в котором используется только что описанный подход к чтению файлов.  
  

```bash
#!/bin/bash
count=1
cat myfile | while read line
do
echo "Line $count: $line"
count=$(( $count + 1 ))
done
echo "Finished"
```

  
Посмотрим на него в деле.  
  

![](/images/89324607c6c7c11435ad782d88950d6f.png)

  
_Чтение данных из файла_  
  
Тут мы передали в цикл `while` содержимое файла и перебрали все строки этого файла, выводя номер и содержимое каждой из них.