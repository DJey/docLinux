# Bash-скрипты

[Bash-скрипты: начало](#bash-скрипты-начало)  
[Bash-скрипты, часть 2: циклы]()  
[Bash-скрипты, часть 3: параметры и ключи командной строки]()  
[Bash-скрипты, часть 4: ввод и вывод]()  
[Bash-скрипты, часть 5: сигналы, фоновые задачи, управление сценариями]()  
[Bash-скрипты, часть 6: функции и разработка библиотек]()  
[Bash-скрипты, часть 7: sed и обработка текстов]()  
[Bash-скрипты, часть 8: язык обработки данных awk]()  
[Bash-скрипты, часть 9: регулярные выражения]()  
[Bash-скрипты, часть 10: практические примеры]()  
[Bash-скрипты, часть 11: expect и автоматизация интерактивных утилит]()

# Bash-скрипты: начало

## Как устроены bash-скрипты

  
Создайте пустой файл с использованием команды`touch`. В его первой строке нужно указать, какую именно оболочку мы собираемся использовать. Нас интересует`bash`, поэтому первая строка файла будет такой:  
  

```
#!/bin/bash
```

  
В других строках этого файла символ решётки используется для обозначения комментариев, которые оболочка не обрабатывает. Однако, первая строка — это особый случай, здесь решётка, за которой следует восклицательный знак (эту последовательность называют[шебанг](https://ru.wikipedia.org/wiki/%D0%A8%D0%B5%D0%B1%D0%B0%D0%BD%D0%B3_(Unix))) и путь к`bash`, указывают системе на то, что сценарий создан именно для`bash`.  
  
Команды оболочки отделяются знаком перевода строки, комментарии выделяют знаком решётки. Вот как это выглядит:  
  

```
#!/bin/bash
# This is a comment
pwd
whoami
```

  
Тут, так же, как и в командной строке, можно записывать команды в одной строке, разделяя точкой с запятой. Однако, если писать команды на разных строках, файл легче читать. В любом случае оболочка их обработает.  
  

## Установка разрешений для файла сценария

  
Сохраните файл, дав ему имя`myscript`, и работа по созданию bash-скрипта почти закончена. Сейчас осталось лишь сделать этот файл исполняемым, иначе, попытавшись его запустить, вы столкнётесь с ошибкой`Permission denied`.  
  

![](/images/29f7433ec002900e7518396a814fe351.png)

  
_Попытка запуска файла сценария с неправильно настроенными разрешениями_  
  
Сделаем файл исполняемым:  
  

```
chmod +x ./myscript
```

  
Теперь попытаемся его выполнить:  
  

```
./myscript
```

  
После настройки разрешений всё работает как надо.  
  

![](/images/736e671a5ff9a96e10bbb3c7e8ae537a.png)

  
_Успешный запуск bash-скрипта_  
  

## Вывод сообщений

  
Для вывода текста в консоль Linux применяется команда`echo`. Воспользуемся знанием этого факта и отредактируем наш скрипт, добавив пояснения к данным, которые выводят уже имеющиеся в нём команды:  
  

```
#!/bin/bash
# our comment is here
echo "The current directory is:"
pwd
echo "The user logged in is:"
whoami
```

  
Вот что получится после запуска обновлённого скрипта.  
  

![](/images/4d0173e3ddcad01d0790b6b98dd91315.png)

  
_Вывод сообщений из скрипта_  
  
Теперь мы можем выводить поясняющие надписи, используя команду`echo`. Если вы не знаете, как отредактировать файл, пользуясь средствами Linux, или раньше не встречались с командой`echo`, взгляните на[этот](https://likegeeks.com/basic-linux-commands-part2/)материал.  
  

## Использование переменных

  
Переменные позволяют хранить в файле сценария информацию, например — результаты работы команд для использования их другими командами.  
  
Нет ничего плохого в исполнении отдельных команд без хранения результатов их работы, но возможности такого подхода весьма ограничены.  
  
Существуют два типа переменных, которые можно использовать в bash-скриптах:  
  

*   Переменные среды
*   Пользовательские переменные

  

## Переменные среды

  
Иногда в командах оболочки нужно работать с некими системными данными. Вот, например, как вывести домашнюю директорию текущего пользователя:  
  

```
#!/bin/bash
# display user home
echo "Home for the current user is: $HOME"
```

  
Обратите внимание на то, что мы можем использовать системную переменную`$HOME`в двойных кавычках, это не помешает системе её распознать. Вот что получится, если выполнить вышеприведённый сценарий.  
  

![](/images/da06b64a489f6a8e16a3ca345f270f82.png)

  
_Использование переменной среды в сценарии_  
  
А что если надо вывести на экран значок доллара? Попробуем так:  
  

```
echo "I have $1 in my pocket"
```

  
Система обнаружит знак доллара в строке, ограниченной кавычками, и решит, что мы сослались на переменную. Скрипт попытается вывести на экран значение неопределённой переменной`$1`. Это не то, что нам нужно. Что делать?  
  
В подобной ситуации поможет использование управляющего символа, обратной косой черты, перед знаком доллара:  
  

```
echo "I have \$1 in my pocket"
```

  
Теперь сценарий выведет именно то, что ожидается.  
  

![](/images/771a8a7102c7a25f1ecd1e739a00de6e.png)

  
_Использование управляющей последовательности для вывода знака доллара_  
  

## Пользовательские переменные

  
В дополнение к переменным среды, bash-скрипты позволяют задавать и использовать в сценарии собственные переменные. Подобные переменные хранят значение до тех пор, пока не завершится выполнение сценария.  
  
Как и в случае с системными переменными, к пользовательским переменным можно обращаться, используя знак доллара:  
TNW-CUS-FMP — промо-код на 10% скидку на наши услуги, доступен для активации в течение 7 дней  

```
#!/bin/bash
# testing variables
grade=5
person="Adam"
echo "$person is a good boy, he is in grade $grade"
```

  
Вот что получится после запуска такого сценария.  
  

![](/images/3a736714c8f9db68ef8fce923b3cc5e5.png)

  
_Пользовательские переменные в сценарии_  
  

## Подстановка команд

  
Одна из самых полезных возможностей bash-скриптов — это возможность извлекать информацию из вывода команд и назначать её переменным, что позволяет использовать эту информацию где угодно в файле сценария.  
  
Сделать это можно двумя способами.  
  

*   С помощью значка обратного апострофа «\`»
*   С помощью конструкции`$()`

  
Используя первый подход, проследите за тем, чтобы вместо обратного апострофа не ввести одиночную кавычку. Команду нужно заключить в два таких значка:  
  

```
mydir=`pwd`
```

  
При втором подходе то же самое записывают так:  
  

```
mydir=$(pwd)
```

  
А скрипт, в итоге, может выглядеть так:  
  

```
#!/bin/bash
mydir=$(pwd)
echo $mydir
```

  
В ходе его работы вывод команды`pwd`будет сохранён в переменной`mydir`, содержимое которой, с помощью команды`echo`, попадёт в консоль.  
  

![](/images/acc127fa3826130cb82854c74d6fd5f4.png)

  
_Скрипт, сохраняющий результаты работы команды в переменной_  
  

## Математические операции

  
Для выполнения математических операций в файле скрипта можно использовать конструкцию вида`$((a+b))`:  
  

```
#!/bin/bash
var1=$(( 5 + 5 ))
echo $var1
var2=$(( $var1 * 2 ))
echo $var2
```

  

![](/images/a3c9b03dcc99367ba2e80f3695282154.png)

  
_Математические операции в сценарии_  
  

## Управляющая конструкция if-then

  
В некоторых сценариях требуется управлять потоком исполнения команд. Например, если некое значение больше пяти, нужно выполнить одно действие, в противном случае — другое. Подобное применимо в очень многих ситуациях, и здесь нам поможет управляющая конструкция`if-then`. В наиболее простом виде она выглядит так:  
  

```
if команда
then
команды
fi
```

  
А вот рабочий пример:  
  

```
#!/bin/bash
if pwd
then
echo "It works"
fi
```

  
В данном случае, если выполнение команды`pwd`завершится успешно, в консоль будет выведен текст «it works».  
  
Воспользуемся имеющимися у нас знаниями и напишем более сложный сценарий. Скажем, надо найти некоего пользователя в`/etc/passwd`, и если найти его удалось, сообщить о том, что он существует.  
  

```
#!/bin/bash
user=likegeeks
if grep $user /etc/passwd
then
echo "The user $user Exists"
fi
```

  
Вот что получается после запуска этого скрипта.  
  

![](/images/395e1765efb8d9b3fe1726240357dcc4.png)

  
_Поиск пользователя_  
  
Здесь мы воспользовались командой`grep`для поиска пользователя в файле`/etc/passwd`. Если команда`grep`вам незнакома, её описание можно найти[здесь](https://likegeeks.com/main-linux-commands-easy-guide/).  
  
В этом примере, если пользователь найден, скрипт выведет соответствующее сообщение. А если найти пользователя не удалось? В данном случае скрипт просто завершит выполнение, ничего нам не сообщив. Хотелось бы, чтобы он сказал нам и об этом, поэтому усовершенствуем код.  
  

## Управляющая конструкция if-then-else

  
Для того, чтобы программа смогла сообщить и о результатах успешного поиска, и о неудаче, воспользуемся конструкцией`if-then-else`. Вот как она устроена:  
  

```
if команда
then
команды
else
команды
fi
```

  
Если первая команда возвратит ноль, что означает её успешное выполнение, условие окажется истинным и выполнение не пойдёт по ветке`else`. В противном случае, если будет возвращено что-то, отличающееся от нуля, что будет означать неудачу, или ложный результат, будут выполнены команды, расположенные после`else`.  
  
Напишем такой скрипт:  
  

```
#!/bin/bash
user=anotherUser
if grep $user /etc/passwd
then
echo "The user $user Exists"
else
echo "The user $user doesn’t exist"
fi
```

  
Его исполнение пошло по ветке`else`.  
  

![](/images/9dbc75b3dba2778a9aa9ff6b77677328.png)

  
_Запуск скрипта с конструкцией if-then-else_  
  
Ну что же, продолжаем двигаться дальше и зададимся вопросом о более сложных условиях. Что если надо проверить не одно условие, а несколько? Например, если нужный пользователь найден, надо вывести одно сообщение, если выполняется ещё какое-то условие — ещё одно сообщение, и так далее. В подобной ситуации нам помогут вложенные условия. Выглядит это так:  
  

```
if команда1
then
команды
elif команда2
then
команды
fi
```

  
Если первая команда вернёт ноль, что говорит о её успешном выполнении, выполнятся команды в первом блоке`then`, иначе, если первое условие окажется ложным, и если вторая команда вернёт ноль, выполнится второй блок кода.  
  

```
#!/bin/bash
user=anotherUser
if grep $user /etc/passwd
then
echo "The user $user Exists"
elif ls /home
then
echo "The user doesn’t exist but anyway there is a directory under /home"
fi
```

  
В подобном скрипте можно, например, создавать нового пользователя с помощью команды`useradd`, если поиск не дал результатов, или делать ещё что-нибудь полезное.  
  

## Сравнение чисел

  
В скриптах можно сравнивать числовые значения. Ниже приведён список соответствующих команд.  
  

> `n1 -eq n2`Возвращает истинное значение, если`n1`равно`n2`.  
> `n1 -ge n2`Возвращает истинное значение, если`n1`больше или равно`n2`.  
> `n1 -gt n2`Возвращает истинное значение, если`n1`больше`n2`.  
> `n1 -le n2`Возвращает истинное значение, если`n1`меньше или равно`n2`.  
> `n1 -lt n2`Возвращает истинное значение, если n1 меньше`n2`.  
> `n1 -ne n2`Возвращает истинное значение, если`n1`не равно`n2`.

  
В качестве примера опробуем один из операторов сравнения. Обратите внимание на то, что выражение заключено в квадратные скобки.  
  

```
#!/bin/bash
val1=6
if [ $val1 -gt 5 ]
then
echo "The test value $val1 is greater than 5"
else
echo "The test value $val1 is not greater than 5"
fi
```

  
Вот что выведет эта команда.  
  

![](/images/bd850959bf5385f0e3a3fa2173fb39a8.png)

  
_Сравнение чисел в скриптах_  
  
Значение переменной`val1`больше чем 5, в итоге выполняется ветвь`then`оператора сравнения и в консоль выводится соответствующее сообщение.  
  

## Сравнение строк

  
В сценариях можно сравнивать и строковые значения. Операторы сравнения выглядят довольно просто, однако у операций сравнения строк есть определённые особенности, которых мы коснёмся ниже. Вот список операторов.  
  

> `str1 = str2`Проверяет строки на равенство, возвращает истину, если строки идентичны.  
> s`tr1 != str2`Возвращает истину, если строки не идентичны.  
> `str1 < str2`Возвращает истину, если`str1`меньше, чем`str2`.  
> `str1 > str2`Возвращает истину, если`str1`больше, чем`str2`.  
> `-n str1`Возвращает истину, если длина`str1`больше нуля.  
> `-z str1`Возвращает истину, если длина`str1`равна нулю.

  
Вот пример сравнения строк в сценарии:  
  

```
#!/bin/bash
user ="likegeeks"
if [$user = $USER]
then
echo "The user $user  is the current logged in user"
fi
```

  
В результате выполнения скрипта получим следующее.  
  

![](/images/55c79a3f28c78c48bcb0560236e09f9c.png)

  
_Сравнение строк в скриптах_  
  
Вот одна особенность сравнения строк, о которой стоит упомянуть. А именно, операторы «>» и «<» необходимо экранировать с помощью обратной косой черты, иначе скрипт будет работать неправильно, хотя сообщений об ошибках и не появится. Скрипт интерпретирует знак «>» как команду перенаправления вывода.  
  
Вот как работа с этими операторами выглядит в коде:  
  

```
#!/bin/bash
val1=text
val2="another text"
if [ $val1 \> $val2 ]
then
echo "$val1 is greater than $val2"
else
echo "$val1 is less than $val2"
fi
```

  
Вот результаты работы скрипта.  
  

![](/images/4cf2c4079e42367f9e061cfee547e6b0.png)

  
_Сравнение строк, выведенное предупреждение_  
  
Обратите внимание на то, что скрипт, хотя и выполняется, выдаёт предупреждение:  
  

```
./myscript: line 5: [: too many arguments
```

  
Для того, чтобы избавиться от этого предупреждения, заключим`$val2`в двойные кавычки:  
  

```
#!/bin/bash
val1=text
val2="another text"
if [ $val1 \> "$val2" ]
then
echo "$val1 is greater than $val2"
else
echo "$val1 is less than $val2"
fi
```

  
Теперь всё работает как надо.  
  

![](/images/8e9cd9a8f743b7789841173671cfe26c.png)

  
_Сравнение строк_  
  
Ещё одна особенность операторов «>» и «<» заключается в том, как они работают с символами в верхнем и нижнем регистрах. Для того, чтобы понять эту особенность, подготовим текстовый файл с таким содержимым:  
  

```
Likegeeks
likegeeks
```

  
Сохраним его, дав имя`myfile`, после чего выполним в терминале такую команду:  
  

```
sort myfile
```

  
Она отсортирует строки из файла так:  
  

```
likegeeks
Likegeeks
```

  
Команда`sort`, по умолчанию, сортирует строки по возрастанию, то есть строчная буква в нашем примере меньше прописной. Теперь подготовим скрипт, который будет сравнивать те же строки:  
  

```
#!/bin/bash
val1=Likegeeks
val2=likegeeks
if [ $val1 \> $val2 ]
then
echo "$val1 is greater than $val2"
else
echo "$val1 is less than $val2"
fi
```

  
Если его запустить, окажется, что всё наоборот — строчная буква теперь больше прописной.  
  

![](/images/ccac6688ceb2d01f4e906620c8c0244a.png)

  
_Команда sort и сравнение строк в файле сценария_  
  
В командах сравнения прописные буквы меньше строчных. Сравнение строк здесь выполняется путём сравнения ASCII-кодов символов, порядок сортировки, таким образом, зависит от кодов символов.  
  
Команда`sort`, в свою очередь, использует порядок сортировки, заданный в настройках системного языка.  
  

## Проверки файлов

  
Пожалуй, нижеприведённые команды используются в bash-скриптах чаще всего. Они позволяют проверять различные условия, касающиеся файлов. Вот список этих команд.  
  

> `-d file`Проверяет, существует ли файл, и является ли он директорией.  
> `-e file`Проверяет, существует ли файл.  
> `-f file`Проверяет, существует ли файл, и является ли он файлом.  
> `-r file`Проверяет, существует ли файл, и доступен ли он для чтения.  
> `-s file П`роверяет, существует ли файл, и не является ли он пустым.  
> `-w file`Проверяет, существует ли файл, и доступен ли он для записи.  
> `-x file`Проверяет, существует ли файл, и является ли он исполняемым.  
> `file1 -nt file2`Проверяет, новее ли`file1`, чем`file2`.  
> `file1 -ot file2`Проверяет, старше ли`file1`, чем`file2`.  
> `-O file`Проверяет, существует ли файл, и является ли его владельцем текущий пользователь.  
> `-G file`Проверяет, существует ли файл, и соответствует ли его идентификатор группы идентификатору группы текущего пользователя.

  
Эти команды, как впрочем, и многие другие рассмотренные сегодня, несложно запомнить. Их имена, являясь сокращениями от различных слов, прямо указывают на выполняемые ими проверки.  
  
Опробуем одну из команд на практике:  
  

```
#!/bin/bash
mydir=/home/likegeeks
if [ -d $mydir ]
then
echo "The $mydir directory exists"
cd $ mydir
ls
else
echo "The $mydir directory does not exist"
fi
```

  
Этот скрипт, для существующей директории, выведет её содержимое.  
  

![](/images/ab22e20e730bb0c56cef8da5c8d31dba.png)

  
_Вывод содержимого директории_  
  
Полагаем, с остальными командами вы сможете поэкспериментировать самостоятельно, все они применяются по тому же принципу.