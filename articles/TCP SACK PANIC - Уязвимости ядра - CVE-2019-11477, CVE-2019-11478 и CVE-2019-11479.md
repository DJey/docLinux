# TCP SACK PANIC - Уязвимости ядра - CVE-2019-11477, CVE-2019-11478 и CVE-2019-11479

## Управляющее резюме

В работе ядра TCP с сетью TCP было обнаружено три связанных недостатка. Самая серьезная уязвимость может позволить удаленному злоумышленнику вызвать панику ядра в системах, на которых работает уязвимое программное обеспечение, и, как следствие, повлиять на работу системы. доступность.

Проблемам было назначено несколько CVE: [CVE-2019-11477](https://access.redhat.com/security/cve/CVE-2019-11477) считается [Важным](https://access.redhat.com/security/updates/classification/) серьезность, тогда как [CVE-2019-11478](http://access.redhat.com/security/cve/CVE-2019-11478) и [CVE-2019-11479](http://access.redhat.com/security/cve/CVE-2019-11479) считаются [умеренными](https://access.redhat.com/security/updates/classification/) серьезностью.

Первые два относятся к пакетам выборочного подтверждения (Selective Acknowledgement -SACK) в сочетании с максимальным размером сегмента (Maximum Segment Size - MSS), третьи - только с максимальным размером сегмента (MSS).

Эти проблемы могут быть исправлены путем применения исправлений или исправлений ядра. Подробные сведения о митигации и ссылки на рекомендации RHSA можно найти на вкладке RESOLVE этой статьи.

## Детали и история вопроса

В обработке ядром Linux обработки пакетов выборочного подтверждения TCP (SACK) с низким размером MSS было обнаружено три связанных недостатка. Степень воздействия в настоящее время ограничивается отказом в обслуживании. В настоящее время не ожидается повышения привилегий или утечки информации.

Несмотря на то, что представленные в этой статье смягчения доступны, они могут повлиять на трафик из законных источников, для которых требуется правильная передача более низких значений MSS и производительность системы. Пожалуйста, оцените меры по смягчению, которые подходят для среды системы, прежде чем применять.

### Что такое выборочное подтверждение?

Выборочное подтверждение TCP (SACK) - это механизм, в котором получатель данных может информировать отправителя обо всех успешно принятых сегментах. Это позволяет отправителю повторно передавать сегменты потока, отсутствующие в его «известном хорошем» наборе. Когда TCP SACK отключен, для повторной передачи всего потока требуется гораздо больший набор повторных передач.

### Что такое MSS?

Максимальный размер сегмента (MSS) - это набор параметров в заголовке TCP пакета, который указывает общий объем данных, содержащихся в восстановленном сегменте TCP.
Поскольку пакеты могут стать фрагментированными при передаче по разным маршрутам, хост должен указать MSS как равный наибольшему размеру полезной нагрузки дейтаграммы IP, который может обработать хост. Очень большие размеры MSS могут означать, что поток пакетов в конечном итоге фрагментируется на пути к месту назначения, тогда как меньшие пакеты могут обеспечить меньшую фрагментацию, но в итоге неиспользованные издержки.

  
Операционные системы и типы транспорта могут по умолчанию указывать размеры MSS. Злоумышленники с привилегированным доступом могут создавать необработанные пакеты с особыми параметрами MSS в пакете для создания этой атаки.

### TCP SACKs:

TCP - это протокол, ориентированный на соединение. Когда две стороны хотят установить связь по TCP-соединению, они устанавливают соединение путем обмена определенной информацией, такой как запрос на инициирование (SYN) соединения, начальный порядковый номер, номер подтверждения, максимальный размер сегмента (MSS) для использования по этому соединению, разрешение отправлять и обрабатывать выборочные подтверждения (SACK) и т. д. Этот процесс установления соединения известен как трехстороннее рукопожатие.

TCP отправляет и получает пользовательские данные с помощью блока Segment. Сегмент TCP состоит из заголовка TCP, параметров и пользовательских данных.  
 ![TCP Segmentation](/images/30d0cfbfbb47c61657c9540b42ed5a4b.png)

##   

Each TCP segment has a Sequence Number (SEQ) and Acknowledgement Number (ACK).

These SEQ & ACK numbers are used to track which segments are successfully received by the receiver. ACK number indicates the next expected segment by the receiver.

Example: user ‘A’ above sends 1 kilobytes of data through 13 segments of 100 bytes each, 13 because each segment has TCP header of 20 bytes. On the receiving end, user ‘B’ receives segments 1, 2, 4, 6, 8 - 13, segments 3, 5 and 7 are lost, not received by user ‘B’.

By using ACK numbers, user ‘B’ will indicate that it is expecting segment number 3, which the user ‘A’ reads as none of the segments after 2 were received by the user ‘B’,and user ‘A’ will retransmit all the segments from 3 onwards, even though segments 4, 6 and 8-13 were successfully received by user ‘B’. User ‘B’ has no way to indicate that to user ‘A’. This leads to an inefficient usage of the network.

### Selective Acknowledgement: SACK

To overcome above problem, Selective Acknowledgement(SACK) mechanism was devised and defined by RFC-2018. With Selective Acknowledgement(SACK), user ‘B’ above uses its TCP options field to inform user ‘A’ about all the segments(1,2,4,6,8-13) it has received successfully, so user ‘A’ needs to retransmit only segments 3, 5, and 7, thus considerably saving the network bandwidth and avoiding further congestion.

 ** [CVE-2019-11477](http://access.redhat.com/security/cve/CVE-2019-11477) SACK Panic:**   
Socket Buffers( [SKB](http://vger.kernel.org/~davem/skb_data.html) ):  
Socket Buffer (SKB) is the most central data structure used in the Linux TCP/IP implementation. It is a linked list of buffers, which holds network packets. Such list can act as a Transmission queue, Receive queue, SACK’d queue, Retransmission queue, etc. SKB can hold packet data into fragments. Linux SKB can hold up to 17 fragments.

> linux/include/linux/skbuff.h  
> define MAX\_SKB\_FRAGS (65536/PAGE\_SIZE + 1)  => 17

With each fragment holding up to 32KB on x86 (64KB on PowerPC) of data. When packet is due to be sent, it’s placed on the Send queue and it’s details are kept in a control buffer structure like

>     linux/include/linux/skbuff.h  
> struct tcp\_skb\_cb {  
>     \_\_u32       seq;                    /\* Starting sequence number \*/  
>     \_\_u32       end\_seq;    /\* SEQ + FIN + SYN + datalen \*/  
>     \_\_u32       tcp\_tw\_isn;  
>         struct {  
>                 u16 tcp\_gso\_segs;  
>                 u16 tcp\_gso\_size;   
>         };  
>     \_\_u8        tcp\_flags;  /2\* TCP header flags. (tcp\[13\])  \*/  
>     …  
> }

Of these, ‘ **tcp\_gso\_segs** ’ and ‘ **tcp\_gso\_size** ’ fields are used to tell device driver about segmentation offload.

When Segmentation offload is on and SACK mechanism is also enabled, due to packet loss and selective retransmission of some packets, SKB could end up holding multiple packets, counted by ‘ **tcp\_gso\_segs** ’. Multiple such SKB in the list are merged together into one to efficiently process different SACK blocks. It involves moving data from one SKB to another in the list. During this movement of data, the SKB structure can reach its maximum limit of 17 fragments and ‘ **tcp\_gso\_segs** ’ parameter can overflow and hit the BUG\_ON() call below resulting in the said kernel panic issue.

> static bool tcp\_shifted\_skb (struct sock \*sk, …, unsigned int pcount, ...)  
> {  
> ...  
> tcp\_skb\_pcount\_add(prev, pcount);  
> BUG\_ON(tcp\_skb\_pcount(skb) < pcount);   <= SACK panic  
> tcp\_skb\_pcount\_add(skb, -pcount);  
> …  
> }

A remote user can trigger this issue by setting the Maximum Segment Size( **MSS** ) of a TCP connection to its lowest limit of 48 bytes and sending a sequence of specially crafted SACK packets. Lowest MSS leaves merely 8 bytes of data per segment, thus increasing the number of TCP segments required to send all data.

## Acknowledgements

Jonathan Looney (Netflix Information Security)

## References

  
 [RFC-2018 - TCP selective acknowledgments](https://tools.ietf.org/html/rfc2018)    
 [How SKB’s work](http://vger.kernel.org/~davem/skb.html) 

 [Netflix (reporters) original report.](https://github.com/Netflix/security-bulletins/blob/master/advisories/third-party/2019-001.md)