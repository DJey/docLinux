# TCP SACK PANIC - Уязвимости ядра - CVE-2019-11477, CVE-2019-11478 и CVE-2019-11479

## Управляющее резюме

В работе ядра TCP с сетью TCP было обнаружено три связанных недостатка. Самая серьезная уязвимость может позволить удаленному злоумышленнику вызвать панику ядра в системах, на которых работает уязвимое программное обеспечение, и, как следствие, повлиять на работу системы. доступность.

Проблемам было назначено несколько CVE: [CVE-2019-11477](https://access.redhat.com/security/cve/CVE-2019-11477) считается [Важным](https://access.redhat.com/security/updates/classification/) серьезность, тогда как [CVE-2019-11478](http://access.redhat.com/security/cve/CVE-2019-11478) и [CVE-2019-11479](http://access.redhat.com/security/cve/CVE-2019-11479) считаются [умеренными](https://access.redhat.com/security/updates/classification/) серьезностью.

Первые два относятся к пакетам выборочного подтверждения (Selective Acknowledgement -SACK) в сочетании с максимальным размером сегмента (Maximum Segment Size - MSS), третьи - только с максимальным размером сегмента (MSS).

Эти проблемы могут быть исправлены путем применения исправлений или исправлений ядра. Подробные сведения о митигации и ссылки на рекомендации RHSA можно найти на вкладке RESOLVE этой статьи.

## Детали и история вопроса

В обработке ядром Linux обработки пакетов выборочного подтверждения TCP (SACK) с низким размером MSS было обнаружено три связанных недостатка. Степень воздействия в настоящее время ограничивается отказом в обслуживании. В настоящее время не ожидается повышения привилегий или утечки информации.

Несмотря на то, что представленные в этой статье смягчения доступны, они могут повлиять на трафик из законных источников, для которых требуется правильная передача более низких значений MSS и производительность системы. Пожалуйста, оцените меры по смягчению, которые подходят для среды системы, прежде чем применять.

### Что такое выборочное подтверждение?

Выборочное подтверждение TCP (SACK) - это механизм, в котором получатель данных может информировать отправителя обо всех успешно принятых сегментах. Это позволяет отправителю повторно передавать сегменты потока, отсутствующие в его «известном хорошем» наборе. Когда TCP SACK отключен, для повторной передачи всего потока требуется гораздо больший набор повторных передач.

### Что такое MSS?

Максимальный размер сегмента (MSS) - это набор параметров в заголовке TCP пакета, который указывает общий объем данных, содержащихся в восстановленном сегменте TCP.
Поскольку пакеты могут стать фрагментированными при передаче по разным маршрутам, хост должен указать MSS как равный наибольшему размеру полезной нагрузки дейтаграммы IP, который может обработать хост. Очень большие размеры MSS могут означать, что поток пакетов в конечном итоге фрагментируется на пути к месту назначения, тогда как меньшие пакеты могут обеспечить меньшую фрагментацию, но в итоге неиспользованные издержки.

  
Операционные системы и типы транспорта могут по умолчанию указывать размеры MSS. Злоумышленники с привилегированным доступом могут создавать необработанные пакеты с особыми параметрами MSS в пакете для создания этой атаки.

### TCP SACKs:

TCP - это протокол, ориентированный на соединение. Когда две стороны хотят установить связь по TCP-соединению, они устанавливают соединение путем обмена определенной информацией, такой как запрос на инициирование (SYN) соединения, начальный порядковый номер, номер подтверждения, максимальный размер сегмента (MSS) для использования по этому соединению, разрешение отправлять и обрабатывать выборочные подтверждения (SACK) и т. д. Этот процесс установления соединения известен как трехстороннее рукопожатие.

TCP отправляет и получает пользовательские данные с помощью блока Segment. Сегмент TCP состоит из заголовка TCP, параметров и пользовательских данных.  

 ![TCP Segmentation](/images/30d0cfbfbb47c61657c9540b42ed5a4b.png)

Каждый сегмент TCP имеет порядковый номер (SEQ) и номер подтверждения (ACK).

Эти номера SEQ и ACK используются для отслеживания того, какие сегменты были успешно приняты получателем. Номер ACK указывает следующий ожидаемый сегмент получателем.

Пример: пользователь «A» выше отправляет 1 килобайт данных через 13 сегментов по 100 байт каждый, 13, потому что каждый сегмент имеет заголовок TCP размером 20 байт. На принимающей стороне пользователь «B» получает сегменты 1, 2, 4, 6, 8–13, сегменты 3, 5 и 7 теряются, а пользователь «B» не получает их.

Используя номера ACK, пользователь «B» будет указывать, что он ожидает сегмент № 3, который пользователь «A» читает, поскольку ни один из сегментов после того, как 2 не был получен пользователем «B» и пользователь «A» будет повторно передавать все сегменты с 3 и далее, даже если сегменты 4, 6 и 8-13 были успешно получены пользователем «B». Пользователь «B» не имеет возможности указать это пользователю «A». Это приводит к неэффективному использованию сети.

### Выборочное подтверждение: SACK

Чтобы преодолеть вышеуказанную проблему, RFC-2018 разработал и определил механизм избирательного подтверждения (SACK). С помощью селективного подтверждения (SACK) пользователь «B» выше использует свое поле параметров TCP для информирования пользователя «A» обо всех сегментах (1,2,4,6,8-13), которые он получил успешно Таким образом, пользователю «А» необходимо повторно передавать только сегменты 3, 5 и 7, тем самым значительно экономя пропускную способность сети и избегая дальнейшей перегрузки.

 ** [CVE-2019-11477](http://access.redhat.com/security/cve/CVE-2019-11477) SACK 
Panic:**   
Socket Buffers( [SKB](http://vger.kernel.org/~davem/skb_data.html) ):  
Сокетный буфер (SKB) - это самая центральная структура данных, используемая в реализации TCP / IP в Linux. Это связанный список буферов, который содержит сетевые пакеты. Такой список может действовать как очередь передачи, очередь приема, очередь SACK, очередь повторной передачи и т. Д. SKB может хранить пакетные данные в виде фрагментов. Linux SKB может содержать до 17 фрагментов.

> linux/include/linux/skbuff.h  
> define MAX\_SKB\_FRAGS (65536/PAGE\_SIZE + 1)  => 17

With each fragment holding up to 32KB on x86 (64KB on PowerPC) of data. When packet is due to be sent, it’s placed on the Send queue and it’s details are kept in a control buffer structure like

>     linux/include/linux/skbuff.h  
> struct tcp\_skb\_cb {  
>     \_\_u32       seq;                    /\* Starting sequence number \*/  
>     \_\_u32       end\_seq;    /\* SEQ + FIN + SYN + datalen \*/  
>     \_\_u32       tcp\_tw\_isn;  
>         struct {  
>                 u16 tcp\_gso\_segs;  
>                 u16 tcp\_gso\_size;   
>         };  
>     \_\_u8        tcp\_flags;  /2\* TCP header flags. (tcp\[13\])  \*/  
>     …  
> }

Of these, ‘ **tcp\_gso\_segs** ’ and ‘ **tcp\_gso\_size** ’ fields are used to tell device driver about segmentation offload.

When Segmentation offload is on and SACK mechanism is also enabled, due to packet loss and selective retransmission of some packets, SKB could end up holding multiple packets, counted by ‘ **tcp\_gso\_segs** ’. Multiple such SKB in the list are merged together into one to efficiently process different SACK blocks. It involves moving data from one SKB to another in the list. During this movement of data, the SKB structure can reach its maximum limit of 17 fragments and ‘ **tcp\_gso\_segs** ’ parameter can overflow and hit the BUG\_ON() call below resulting in the said kernel panic issue.

> static bool tcp\_shifted\_skb (struct sock \*sk, …, unsigned int pcount, ...)  
> {  
> ...  
> tcp\_skb\_pcount\_add(prev, pcount);  
> BUG\_ON(tcp\_skb\_pcount(skb) < pcount);   <= SACK panic  
> tcp\_skb\_pcount\_add(skb, -pcount);  
> …  
> }

A remote user can trigger this issue by setting the Maximum Segment Size( **MSS** ) of a TCP connection to its lowest limit of 48 bytes and sending a sequence of specially crafted SACK packets. Lowest MSS leaves merely 8 bytes of data per segment, thus increasing the number of TCP segments required to send all data.

## Acknowledgements

Jonathan Looney (Netflix Information Security)

## References

  
 [RFC-2018 - TCP selective acknowledgments](https://tools.ietf.org/html/rfc2018)    
 [How SKB’s work](http://vger.kernel.org/~davem/skb.html) 

 [Netflix (reporters) original report.](https://github.com/Netflix/security-bulletins/blob/master/advisories/third-party/2019-001.md)